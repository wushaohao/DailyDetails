优点：

　　1. 装饰模式可以提供比继承更多地灵活性。
　　2. 可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。
　　3. 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
　　4. 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。

缺点：

　　1. 会产生很多的小对象（具体装饰类），增加了系统的复杂性。
　　2. 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。


装饰模式：

　　在不改变接口的前提下，动态扩展对象的访问。
　　动态继承，让类具有在运行期改变行为的能力。
　　装饰模式，突出的是运行期增加行为，这和继承是不同的，继承是在编译期增加行为。
　　强调：增强

代理模式：

　　在不改变接口的前提下，控制对象的访问。
　　1.从封装的角度讲，是为了解决类与类之间相互调用而由此导致的耦合关系，可以说是接口的另外一个层引用。
　　　　比如：在a类->b代理->c类这个关系中，c类的一切行为都隐藏在b中。即调用者不知道要访问的内容与代理了什么对象。
　　2.从复用的角度讲，可以解决不同类调用一个复杂类时，仅仅因较小的改变而导致整个复杂类新建一个类。
　　　　比如：a类->c类1；b类->c类2。
　　　　可以变为a类->ca代理类->c类；b类->cb代理类-c类。
　　代理模式，是类之间的封装和（某方面的）复用。
　　强调：限制



装饰者模式和代理模式的区别:
  二者的代码实现上非常的类似，但是就行为目的而言，二者是相反的（装饰模式：增强，代理模式：限制）
装饰器模式：能动态的新增或组合对象的行为。
代理模式：为其他对象提供一种代理以控制对这个对象的访问.（换句话说，可以不执行某功能）
装饰模式是“新增行为”，而代理模式是“控制访问”。

装饰模式是在原有基础之上增加额外的功能，而代理模式有两种情况可以使用第一种是延迟代理对象，对于大文件或者目前还未加载完的对象，使用比较合适。第二种为权限判断，在调用功能前判断当前用户是否有此权限。

代理模式不是嵌套调用的。

装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；
代理模式给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用；
装饰模式应该为所装饰的对象增强功能；
代理模式对代理的对象施加控制，并不提供对象本身的增强功能