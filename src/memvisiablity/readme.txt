内存可见性

可见性:一个线程对共享变量的修改，能够及时被其他线程看到
共享变量:如果一个变量在多个线程的工作内存中存在副本，那么这个变量就是这几个线程的共享变量
java内存模型(java Memory Model)描述了java程序中各种变量(线程共享变量)的访问规则,以及在JVM中将变量存储到内存和从内存中读区变量这样的底层细节

java内存模型(JMM)
所有的变量都存储在主内存中
每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)

    线程1             线程2           线程3
     👇                👇              👇
  工作内存1          工作内存2        工作内存3
  (X的副本1)        (X的副本2)      (X的副本3)
                       👇
                     主内存
                   (共享变量X)

两条规定:
  a.线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中进行读写
  b.不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成

共享变量可见性实现的原理:
 线程1对共享变量的修改要使得线程2看到，必须经过如下步骤:
 1.把工作内存1中更新过的共享变量刷新到主内存
 2.把主内存中最新的共享变量的值更新到工作内存2中

    线程1            线程2
     👇               👆
   工作内存1        工作内存2
    (x=1)           (x=1)
     👇               👆
            主内存
            (x=1)


可见性:
要实现共享变量的可见性，必须保证两点:
   1.线程修改后的共享变量值能够及时从工作内存刷新到主内存中
   2.其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中



指令重排序:
   代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化
   1.编译器级优化重排序(编译器优化)
   2.指令级并行重排序(处理器优化)
   3.内存系统的重排序(处理器优化)


as-if-serial
  无论怎么进行重排序，程序执行的结果应该与代码顺序执行的结果一致(Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义)
 例子:
     int num1=1;  //第一行代码
     int num2=1;  //第二行代码
     int result=num1+num2;  //第三行代码
     单线程情况下:第一二行的顺序可以重排，但第三行不能，重排序不会给单线程带来内存可见性问题，多线程中程序会交错执行时，重排序可能会造成内存可见性问题

可见性分析:
    导致共享变量在线程间不可见原因:
        1.线程的交叉执行
        2.重排序结合线程交叉执行
        3.共享变量更新后的值没有在工作内存与主内存间及时更新

可见性实现方式:
1.synchronized
  能够实现:a.原子性(同步) b.可见性
  JMM关于Synchronized两条规定:
     1.线程解锁前，必须把共享变量的最新值刷新到主内存中
     2.线程加锁时，将清空工作内存中的共享变量值，从而使用共享变量时需要从主内存中重新读取最新的值(注意:加锁与解锁是同一把锁)
   这样，线程解锁前对共享变量的修改在下次加锁时对其他线程可见

  线程执行互斥代码的过程:
  1.获得互斥锁
  2.清空工作内存
  3.从主内存拷贝变量的最新副本到工作内存
  4.执行锁内部代码
  5.将更改后的共享变量的值刷新到主内存
  6.释放互斥锁

2.volatile
  1.能够保证volatile变量的可见性
  2.不能保证volatile变量复合操作的原子性

  volatile如何实现内存可见性:
  深入来说:通过加入内存屏障和禁止重排序优化来实现的
  对volatile变量执行写操作时会在写操作后加入一条store屏障指令
  对volatile变量执行读操作时会在写操作后加入一条load屏障指令
  通俗的讲:volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到
该变量的最新值。

   线程写volatile变量的过程:
   1.改变线程工作内存volatile变量副本的值
   2.将改变后的副本的值从工作内存刷新到主内存

   线程读volatile变量的过程:
   1.从主内存中读取volatile变量的最新值到线程的工作内存中
   2.从工作内存中读取volatile变量的副本


volatile适用场合:
1.对变量的写入操作不依赖当前值
   不满足:number++、count=count*5等
   满足:boolean变量、记录温度变化的变量等

2.该变量没有包含在具有其他变量的不变式中
   不满足:不变式low<up


synchronized与volatile比较:
1.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程(从内存可见性角度讲，volatile读相当于synchronized的加锁操作，volatile写操作相当于synchronized的解锁操作)
2.synchronized既能保持内存可见性又能保证原子性，而volatile只能保持内存可见性不能保证原子性


即使没有保证可见性的措施，很多时候共享变量依然能够在主内存和工作内存间得到及时的更新？
 因为 一般只有在短时间内高并发的情况下 才会出现变量得不到及时更新的情况，因为CPU在执行时会很快地刷新缓存，所以一般情况下很难看到这种问题