package callback;

/**
 *
 * @author wuhao
 * @date 17/2/5
 *
 * 函数回调
 * 当下层函数方法处理完成的时候 某一条件触发将结果或一些需要上层函数处理的 回调上层函数进行处理
 * 一般来说，模块之间都存在一定的调用关系，从调用方式上看，可以分为三类同步调用、异步调用和回调。同步调用是一种阻塞式调用，
 * 即在函数A的函数体里通过书写函数B的函数名来调用之，使内存中对应函数B的代码得以执行。异步调用是一种类似消息或事件的机制解决了同步阻塞的问题，
 * 例如 A通知 B后，他们各走各的路，互不影响，不用像同步调用那样， A通知 B后，非得等到 B走完后， A才继续走 。回调是一种双向的调用模式，也就是说，
 * 被调用的接口被调用时也会调用对方的接口，例如A要调用B，B在执行完又要调用A。
 * 2、回调的用途
 * 回调一般用于层间协作，上层将本层函数安装在下层，这个函数就是回调，而下层在一定条件下触发回调。例如作为一个驱动，是一个底层，他在收到一个数据时，
 * 除了完成本层的处理工作外，还将进行回调，将这个数据交给上层应用层来做进一步处理，这在分层的数据通信中很普遍。
 * 原理：首先创建一个回调对象，然后再创建一个控制器对象，将回调对象需要被调用的方法告诉控制器对象，控制器对象负责检查某个场景是否出现或某个条件是否满足，
 * 当满足时，自动调用回调对象的方法。例如老板A对员工B说，我现在交给你一个任务，并且我把我的电话号码给你，你一旦完成任务就给我打电话
 */
public class Employee {

    Work work1;

    public Employee(Work worker){
        this.work1=worker;
    }

    public void work(){
        System.out.println("我正在努力工作!");
        work1.callmeOk();
    }
    public static void main(String[] args) {
        Employee employee=new Employee(new Boss());
        employee.work();
    }
}
